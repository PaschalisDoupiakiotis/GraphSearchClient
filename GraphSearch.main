package graphSearch;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Arrays;
import java.util.Collections;

import graphClient.XGraphClient;

public class GraphSearch {

    public int afm = 58960; // AFM should be in form 5XXXX
    public String firstname = "Paschalis";
    public String lastname = "Doupiakiotis";

    XGraphClient xgraph;

    public GraphSearch(XGraphClient xgraph) {
       this.xgraph = xgraph;
    }


    public Result findResults() {
       Result res = null;

       // ////////////////////
       // WRITE YOUR OWN CODE
       // ////////////////////

       // EXAMPLE CODE

       // Example of creating the Result object
       res = new Result();

       // Retrieve the number of clusters (parameter k of maximum spacing clustering)
       int numOfClusters = xgraph.getNumOfClusters();

       // Retrieve the first node of the unknown graph
       long firstNode = xgraph.firstNode();

       // Print the ID of the first node
       System.out.println("The id of the first node is: " + firstNode);

       // Inform that GraphSearch starts
       System.out.println("Graph search from node : " + firstNode);

       //New line
       System.out.println();

       //A FIFO queue to store nodes that have to be visited
       LinkedList<Long> list = new LinkedList<>();

       //A structure for storing every node that has been found
       HashSet<Long> nodesDiscovered = new HashSet<>();

       //Degree Array
       ArrayList<Integer> degreeArrayList = new ArrayList<>();


       list.addFirst(firstNode);
       nodesDiscovered.add(firstNode);

       // Retrieve the neighbors of the first node
       // The neighbors are given in NO particular order.
       //long[] neighbors = xgraph.getNeighborsOf(firstNode);

       // Convert long[] to ArrayList<Long>
//     Long[] a = new Long[10];
//     Arrays.fill(a, 123L);
//     ArrayList<Long> n = new ArrayList<Long>(Arrays.asList(a));
//
//     long[] input = new long[]{1,2,3,4};
//     List<Long> output = new ArrayList<Long>();
//     for (long value : input) {
//         output.add(value);
//     }
//
       // Print all the neighbors of the firstNode
       // Approach A
       //int numOfNeighbors = neighbors.length;

       //for (int i = 0; i < numOfNeighbors; i++) {
       // System.out.println("Neighbor " + i + ", id: " + neighbors[i]);
       //}

       // newline
       //System.out.println();

       // Print all the neighbors of the firstNode
       // Approach B
       //for (long id : neighbors) {
       // System.out.println("Neighbor id: " + id);
       //}

       int sumOfAllDegrees=0;
       int numOfNodes=0;

       while(!list.isEmpty()){
          long currentNode=list.removeLast();

          System.out.println("Node : " + currentNode);

          long[] neighbors=xgraph.getNeighborsOf(currentNode);
          Arrays.sort(neighbors);

          degreeArrayList.add(neighbors.length);

          for(long node: neighbors){
             sumOfAllDegrees++;

             if(!nodesDiscovered.contains(node)){
                list.addFirst(node);
                nodesDiscovered.add(node);
             }
          }
       }

       numOfNodes=nodesDiscovered.size();
       Collections.sort(degreeArrayList, Collections.reverseOrder());

       // WRITE ALL RESULTS INTO THE RESULT OBJECT

       // COMPULSORY questions
       res.n = numOfNodes;//(Number of nodes, type: int)
       res.m = sumOfAllDegrees/2; //(Number of edges, type: int)
       res.degreeArrayList = degreeArrayList;//(Degrees in decreasing order, ArrayList<Integer>)

       // BONUS
       // res.bfsNodeSequence = ... ArrayList<Long>
       // res.bfsTree = ... SGraph

       // Return the res (Result) Object with the results of the computation
       return res;
    }

}
